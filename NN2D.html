<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Neural Network Visualization 2D</title>
<style type="text/css">
body { color: #00FF00; background-color:black;}
canvas#RenderWindow {border:2px solid #00FF00;width:200px; height:200px;}
table {
    border-collapse: collapse;
}
table, td {
    border: 1px solid #00FF00;
}
table.NoBorder td {
    border: 1px solid black;
}
</style>
<script>
/*=========================================================================================
Created by Alan Wolfe February 2017
http://demofox.org
http://blog.demofox.org
https://twitter.com/Atrix256
=========================================================================================*/

//=========================================================================================
var vertexShaderSource = ` 
// inputs
in vec4 a_position;

// outputs
out vec2 v_screenPosition;  // in [-1.0, 1.0]

// logic 
void main() {
    v_screenPosition = a_position.xy;
    gl_Position = vec4(a_position.xy, 0.0, 1.0);
}
`;
 
//=========================================================================================
var fragmentShaderSource = `

precision mediump float;
precision mediump sampler2D;
precision mediump sampler3D;

// inputs
in vec2 v_screenPosition;  // in [-0.5, 0.5]

// uniforms
uniform float u_scale;
uniform bool u_discreteOutput;

// outputs
out vec4 outColor;

float NeuronActivate (float value)
{
    // linear (identity)
    //return value;

    // Step
    return value > 0.0 ? 1.0 : 0.0;

    // Sigmoid
    //return 1.0 / (1.0 + exp(-value));

    // hyperbolic tangent
    //float eposz = exp(value);
    //float enegz = exp(-value);
    //return (eposz - enegz) / (eposz + enegz);

    // Relu
    //return max(0.0, value);
}

float Neuron (vec2 neuronInput, vec2 weights, float bias)
{
    float neuronValue = dot(vec3(neuronInput, 1.0), vec3(weights, bias));
    return NeuronActivate(neuronValue);
}

float F (vec2 pos)
{
    pos *= u_scale;

    // x axis
    //return pos.x;

    // bilinear
    //return pos.x*pos.y;

    // Circle
    //return sqrt(pos.x*pos.x+pos.y*pos.y) - 0.5;

    // Line
    //return dot(pos, normalize(vec2(1.0, 1.0)));

    // single layer neural network. Take three inputs, spit out a single output
    //return NeuronActivate(Neuron(pos, vec3(0.1, 0.3, 0.2), -0.3));


    // a simpler multi layer network?
    float H1A = Neuron(pos, vec2(1.0, 0.0), 0.0);
    float H1B = Neuron(pos, vec2(0.0, 1.0), 0.0);

    float H2 = Neuron(vec2(H1A,H1B), vec2(1.0, 1.0), 0.0);

    return H1A;


#if 0
    // Double layer neural network. Take three inputs, make three outputs.  Activation function for each, then use those as input the last layer.
    float H1 = Neuron(pos, vec3(0.1, 0.3, 0.2), -0.3);
    float H2 = Neuron(pos, vec3(0.2, 0.3, 0.1), -0.2);
    float H3 = Neuron(pos, vec3(0.3, 0.2, 0.2), -0.1);

    return Neuron(vec3(H1, H2, H3), vec3(0.6, 0.1, 0.2), -0.2);
#endif
}

void main() {
    // evaluate the network at this pixel's location.
    float value = F(v_screenPosition * u_scale);

    // show blue for negative, orange for positive
    if (u_discreteOutput)
    {
        // TODO: may need a small region of white!
        // TODO: discretizing the output may just push it towards 0, 1, -1
        if (value == 0.0)
            outColor.rgb = vec3(1.0, 1.0, 1.0);
        if (value > 0.0)
            outColor.rgb = vec3(1.0, 0.5, 0.0);
        else
            outColor.rgb = vec3(0.0, 0.0, 1.0);
    }
    else
    {
        // TODO: make white be at 0.0
        outColor.rgb = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.5, 0.0), clamp(value*0.5+0.5, 0.0, 1.0));
    }
    outColor.w = 1.0;
}

`;

var gl = null;
var canvas = null;
var uniformBoxColor = null;
var uniformScale = null;
var uniformDiscreteOutput = null;
var shaderProgram = null;
var currentShaderProgram = null;

//=========================================================================================
function createShader (gl, type, source, staticBranches) {
  var fullSource = "#version 300 es\n" + staticBranches + source;

  var shader = gl.createShader(type);
  gl.shaderSource(shader, fullSource);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }
 
  console.log(gl.getShaderInfoLog(shader));
  console.log(fullSource);
  gl.deleteShader(shader);
}

//=========================================================================================
function createProgram (gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

//=========================================================================================
function resize (canvas) {
  // Lookup the size the browser is displaying the canvas.
  var displayWidth  = canvas.clientWidth;
  var displayHeight = canvas.clientHeight;
 
  // Check if the canvas is not the same size.
  if (canvas.width  !== displayWidth ||
      canvas.height !== displayHeight) {
 
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
}

//=========================================================================================
function SetVertexAttributeData (gl, program, name, type, count, values)
{
    var attributeLocation = gl.getAttribLocation(program, name);
    if (attributeLocation == -1)
        return;

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(values), gl.STATIC_DRAW);        

    gl.enableVertexAttribArray(attributeLocation);
    var size = count; 
    var type = type;   
    var normalize = false; 
    var stride = 0;        
    var offset = 0;        
    gl.vertexAttribPointer(attributeLocation, size, type, normalize, stride, offset);      
}

//=========================================================================================
function DrawScene ()
{
    // set which shader we are using
    SelectShaderProgram();

    // update uniforms
    gl.uniform1f(uniformScale, document.getElementById("u_scale").value);
    gl.uniform1f(uniformDiscreteOutput, document.getElementById("u_discreteOutput").checked ? 1.0 : 0.0);

    // make sure gl is rendering to the the right size and has the right viewport info
    resize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // draw our single full screen triangle
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 3;
    gl.drawArrays(primitiveType, offset, count);    

    // request another frame to be drawn
    requestAnimationFrame(DrawScene);
}

//=========================================================================================
function GetPos ( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

//=========================================================================================
function SelectShaderProgram ()
{
    // if we are using the same shader program that we are supposed to be using, nothing to do
    var newShaderProgram = shaderProgram;
    if (newShaderProgram == currentShaderProgram)
        return;

    // switch to the new shader program if we need to change
    currentShaderProgram = newShaderProgram;
    gl.useProgram(currentShaderProgram); 

    // vertex data - a single triangle that covers the screen
    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    SetVertexAttributeData(gl, currentShaderProgram, "a_position", gl.FLOAT, 2,
        [
            -1,  3,
             3, -1,
            -1, -1,
        ]
    );   

    // get uniforms for this shader program
    uniformScale = gl.getUniformLocation(currentShaderProgram, "u_scale");
    uniformDiscreteOutput = gl.getUniformLocation(currentShaderProgram, "u_discreteOutput");
}

//=========================================================================================
function Initialize ()
{
    // setup webgl2
    canvas = document.getElementById("RenderWindow");
    gl = canvas.getContext("webgl2");
    if (!gl)
    {
        alert("This page requires WebGL2, which doesn't seem to be enabled ):");
        return;
    }
    
    // set clear color to black
    gl.clearColor(0, 0, 0, 1);

    // compile all shaders
    var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource, "");
    var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource, "");
    shaderProgram = createProgram(gl, vertexShader, fragmentShader);    

    // start the render loop
    requestAnimationFrame(DrawScene);
}

</script>
</head>
<body onLoad="Initialize()">
<h1>Neural Network Visualization 2D</h1>

This is a demo to go along with my blog post: TODO: link to blog post<br>
<br>
This page uses WebGL2, which is enabled in firefox and chrome.<br>
<br>
Drag the mouse to rotate the surface. Change network topology, layer visualized, and modify weights,biases.<br>
<br>
<table class="NoBorder">
<tr>
    <td><canvas id="RenderWindow"></canvas></td>
    <td valign="top">
        <table>
        <tr><td>Discrete Output:</td><td><input type="checkbox" id="u_discreteOutput"/></td></tr>
        <tr><td>Scale:</td><td><input type="range" min="1" max="10.0" id="u_scale" value="1.0" step="0.01"/></td></tr>
        </table>
    </td>
</tr>
</table>
</body>
</html>

<pre>
TODO:
* make 0 value be a different color? like white maybe
 * both for analog and binary output?

* not sure point of this yet

? I think position from vertex shader should go -1/+1

? make a UI, make multiple windows?

* write explanation of how it works.

* update instructions

* clean up the code, get rid of stuff not needed anymore

* find TODO's above

* blog post later!
* link to blog post

* add this to index.html and upload both to website

* Note:
 * based on http://playground.tensorflow.org/
 * but meant to let you play with weights to get desired shapes, instead of being used for learning


Blog Notes:
* Step function not differentiable.
 * does it matter?
 * i think it prevents analytical derivatives (gradient), but numeric one is fine.
</pre>