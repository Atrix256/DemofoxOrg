<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Ray Marching A Neural Network</title>
<style type="text/css">
body { color: #00FF00; background-color:black;}
canvas#RenderWindow {border:2px solid #00FF00;width:700px; height:700px;}
table {
    border-collapse: collapse;
}
table, td {
    border: 1px solid #00FF00;
}
table.NoBorder td {
    border: 1px solid black;
}
</style>
<script>
/*=========================================================================================
Created by Alan Wolfe February 2017
http://demofox.org
http://blog.demofox.org
https://twitter.com/Atrix256
=========================================================================================*/

//=========================================================================================
var vertexShaderSource = ` 
// inputs
in vec4 a_position;

// outputs
out vec2 v_screenPosition;  // in [-0.5, 0.5]

// logic 
void main() {
    v_screenPosition = a_position.xy / 2.0;
    gl_Position = vec4(a_position.xy, 0.0, 1.0);
}
`;
 
//=========================================================================================
var fragmentShaderSource = `
#define NUM_RAY_STEPS 75

precision mediump float;
precision mediump sampler2D;
precision mediump sampler3D;

// inputs
in vec2 v_screenPosition;  // in [-0.5, 0.5]

// uniforms
uniform vec2 u_mouse;          // z,y:  percent of screen. z: mouse button down or not.
uniform vec3 u_boxColor;          // color of the bounding box.

// outputs
out vec4 outColor;

float Neuron (vec3 neuronInput, vec3 weights, float bias)
{
    return dot(vec4(neuronInput, 1.0), vec4(weights, bias));
}

float NeuronActivate (float value)
{
    // Step
    return value > 0.0 ? 1.0 : 0.0;

    // Sigmoid
    //return 1.0 / (1.0 + exp(-value));

    //return mix(stepValue, sigmoidValue, 0.6);

    // TODO: relu!
}

float F (vec3 pos)
{
    // a bilinear surface
    //return (1.0 - pos.x*pos.z) - pos.y;

    // A sphere
    //pos -= 0.5;
    //return sqrt(pos.x*pos.x+pos.y*pos.y+pos.z*pos.z) - 0.5;

    // a plane
    //return dot(pos, normalize(vec3(0.0, 1.0, 1.0))) - 0.5;

    // single layer neural network. Take three inputs, spit out a single output
    //return Neuron(pos, vec3(0.1, 0.3, 0.2), -0.3);

    // TODO: temp!
    //pos -= 0.5;

    // Double layer neural network. Take three inputs, make three outputs.  Activation function for each, then use those as input the last layer.
    // TODO: NOTE: this is step activation!
    float H1 = Neuron(pos, vec3(0.1, 0.3, 0.2), -0.3);
    float H2 = Neuron(pos, vec3(0.2, 0.3, 0.1), -0.2);
    float H3 = Neuron(pos, vec3(0.3, 0.2, 0.2), -0.1);

    //return H3;

    H1 = NeuronActivate(H1);
    H2 = NeuronActivate(H2);
    H3 = NeuronActivate(H3);

    return Neuron(vec3(H1, H2, H3), vec3(0.6, 0.1, 0.2), -0.2);
}

bool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)
{
    vec3 roo = rayPos - (boxMin+boxMax)*0.5;
    vec3 rad = (boxMax - boxMin)*0.5;

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
    
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    time = vec2( max( max( t1.x, t1.y ), t1.z ),
                 min( min( t2.x, t2.y ), t2.z ) );
    
    return time.y>time.x && time.y>0.0;
}

vec3 SurfaceNormal (vec3 pos)
{
    // TODO: i think this gives the wrong normal. not sure how to properly get normal though.

    // Get gradient via central differences method.
    float eps = 0.1;
    vec3 n = vec3(
        F(vec3(pos.x-eps, pos.y, pos.z)) - F(vec3(pos.x+eps, pos.y, pos.z)),
        F(vec3(pos.x, pos.y-eps, pos.z)) - F(vec3(pos.x, pos.y+eps, pos.z)),
        F(vec3(pos.x, pos.y, pos.z-eps)) - F(vec3(pos.x, pos.y, pos.z+eps))        
    );
    return normalize( n );
}

vec3 SurfaceDiffuse (vec2 uv)
{
    // anti aliased (smoothstepped) checkerboard pattern
    // 10 cells on each axis
    const float cells = 10.0;
    vec2 uvCells = uv * cells;

    // Make a grid where it does half a smoothstep at the border of each cell from 1 to 0, but not the edge of the space.
    // But make an envelope to stop the edge tiles from blending to a tile that isn't there.
    float xaxisBorder = step(uvCells.x, 0.5) + step(cells - 0.5, uvCells.x);
    float yaxisBorder = step(uvCells.y, 0.5) + step(cells - 0.5, uvCells.y);        
    vec2 fractuvCells = fract(uvCells);
    float xaxis = clamp(smoothstep(0.0, 0.025, fractuvCells.x) * smoothstep(1.0, 0.975, fractuvCells.x) + xaxisBorder, 0.0, 1.0);
    float yaxis = clamp(smoothstep(0.0, 0.025, fractuvCells.y) * smoothstep(1.0, 0.975, fractuvCells.y) + yaxisBorder, 0.0, 1.0);
    float value = (xaxis * yaxis * 0.5) + 0.5;
    float cellAA = mix(0.0, 1.0, value);

    // figure out if this is a bright or dark cell
    bool onoff = mod(floor(uvCells.x) + floor(uvCells.y), 2.0) < 1.0;

    // colorize the checkerboard
    float color1 = onoff ? 1.0 : 0.4;
    float color2 = onoff ? 0.4 : 1.0;
    return vec3(mix(color1, color2, cellAA), 0.0, 0.0);
}

// logic
vec3 CalculateColor() {

    //-------------------------
    //----- Camera Setup ------
    //-------------------------

    vec3 cameraAt   = vec3(0.5,0.5,0.5);

    float angleX = 6.28 * (u_mouse.x - 0.5) + 3.54;
    float angleY = ((u_mouse.y - 0.5) * 6.28) + 0.5;
    vec3 cameraPos  = (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;
    cameraPos += vec3(0.5,0.5,0.5);

    vec3 cameraFwd  = normalize(cameraAt - cameraPos);
    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));
    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));

    float cameraViewWidth   = 6.0;
    float cameraViewHeight  = cameraViewWidth;
    float cameraDistance    = 10.0;  // intuitively backwards!

    //-------------------------
    //------ Ray Setup --------
    //-------------------------
    
    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))
                   - (cameraLeft * v_screenPosition.x * cameraViewWidth)
                   + (cameraUp * v_screenPosition.y * cameraViewHeight);
    vec3 rayDir = normalize(rayTarget);

    //-------------------------
    //------ Ray Trace --------
    //-------------------------
    
    // if the ray misses the bounding box, bail out
    vec2 rayMinMax;
    if (!RayIntersectAABox(vec3(0.0, 0.0, 0.0), vec3(1.0,1.0,1.0), cameraPos, rayDir, rayMinMax))
        return vec3(0.0, 0.0, 0.0);

    //-------------------------
    //------ Ray March --------
    //-------------------------

    vec3 rayPos = clamp(cameraPos + rayDir * rayMinMax.x, 0.0, 1.0);
    vec3 rayStop = clamp(cameraPos + rayDir * rayMinMax.y, 0.0, 1.0);
    vec3 rayDelta = (rayStop - rayPos) / float(NUM_RAY_STEPS-1);
    float hitTime = rayMinMax.x;
    float deltaT = (rayMinMax.y - rayMinMax.x) / float(NUM_RAY_STEPS-1);
    float lastHeight = 0.0;
    float lastY = 0.0;
    float height = 0.0;

// TODO: rename height / lastHeight to value / lastValue?
// TODO: what is lastY and such? review vars!

    bool startedAbove = F(rayPos) > 0.0;
    bool hit = false;
    for (int i = 0; i < NUM_RAY_STEPS; ++i)
    {
        height = F(rayPos);

        bool isAbove = height > 0.0;
        hit = (startedAbove != isAbove);
        if (hit)
          break;

        lastHeight = height;
        lastY = rayPos.y;     
        rayPos = clamp(rayPos + rayDelta, 0.0, 1.0);
        hitTime += deltaT;
    }

    // If the surface in the box is missed, set to dark green to show where the box is.
    // If we previously hit a data point, set it to the data point color though.
    if (!hit)
        return u_boxColor;

    // estimate where the hit was
    // TODO: fix hitTime estimation code! Maybe look at lastValue and value, and lerp to find the zero?
    //hitTime = hitTime - deltaT + deltaT*(lastHeight-lastY)/(rayPos.y-lastY-height+lastHeight);
    vec3 rayHitPos = cameraPos + rayDir * hitTime;

    //-------------------------
    //------- Shading ---------
    //-------------------------
    vec3 ret = vec3(0.0);

    vec3 diffuseColor = SurfaceDiffuse(rayHitPos.xz);

    vec3 reverseLightDir = normalize(vec3(2.0, 2.0, 1.5));

    vec3 normal = SurfaceNormal(rayHitPos);
    if (dot(normal, rayDir) > 0.0)
      normal *= -1.0;

    // ambient
    ret = diffuseColor * vec3(0.01);

    // diffuse
    float dp = clamp(dot(normal, reverseLightDir), 0.0, 1.0);
    ret += diffuseColor * dp;

    // specular
    vec3 reflection = reflect(reverseLightDir, normal);
    dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
    ret += pow(dp, 60.0); 

    return ret;
}

void main() {
    // get the color, gamma correct and clamp
    outColor.rgb = clamp(sqrt(CalculateColor()), 0.0, 1.0);
    outColor.w = 1.0;
}

`;

var gl = null;
var canvas = null;
var uniformMouse = null;
var uniformBoxColor = null;
var mouse = {PosX:0, PosX:0, IsDown: false};
var mouseClicked = false;
var shaderProgram = null;
var currentShaderProgram = null;

//=========================================================================================
function createShader (gl, type, source, staticBranches) {
  var fullSource = "#version 300 es\n" + staticBranches + source;

  var shader = gl.createShader(type);
  gl.shaderSource(shader, fullSource);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }
 
  console.log(gl.getShaderInfoLog(shader));
  console.log(fullSource);
  gl.deleteShader(shader);
}

//=========================================================================================
function createProgram (gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

//=========================================================================================
function resize (canvas) {
  // Lookup the size the browser is displaying the canvas.
  var displayWidth  = canvas.clientWidth;
  var displayHeight = canvas.clientHeight;
 
  // Check if the canvas is not the same size.
  if (canvas.width  !== displayWidth ||
      canvas.height !== displayHeight) {
 
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
}

//=========================================================================================
function SetVertexAttributeData (gl, program, name, type, count, values)
{
    var attributeLocation = gl.getAttribLocation(program, name);
    if (attributeLocation == -1)
        return;

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(values), gl.STATIC_DRAW);        

    gl.enableVertexAttribArray(attributeLocation);
    var size = count; 
    var type = type;   
    var normalize = false; 
    var stride = 0;        
    var offset = 0;        
    gl.vertexAttribPointer(attributeLocation, size, type, normalize, stride, offset);      
}

//=========================================================================================
function DrawScene ()
{
    // set which shader we are using
    SelectShaderProgram();

    // hacky work around for some unknown thing changing the mouse value in the first couple frames!
    // I did a console.log at each place the mouse value is modified, and it wasn't any of them!!
    if (!mouseClicked)
    {
        mouse.PosX = gl.canvas.width / 2;
        mouse.PosY = gl.canvas.height / 2;
    }

    // update uniforms
    gl.uniform2fv(uniformMouse, [mouse.PosX / gl.canvas.width, mouse.PosY / gl.canvas.height]);

    if (document.getElementById("u_boxColor").checked)
        gl.uniform3fv(uniformBoxColor, [0,0.04,0]);
    else
        gl.uniform3fv(uniformBoxColor, [0,0,0]);        

    // make sure gl is rendering to the the right size and has the right viewport info
    resize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // draw our single full screen triangle
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 3;
    gl.drawArrays(primitiveType, offset, count);    

    // request another frame to be drawn
    requestAnimationFrame(DrawScene);
}

//=========================================================================================
function GetPos ( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

//=========================================================================================
function SelectShaderProgram ()
{
    // if we are using the same shader program that we are supposed to be using, nothing to do
    var newShaderProgram = shaderProgram;
    if (newShaderProgram == currentShaderProgram)
        return;

    // switch to the new shader program if we need to change
    currentShaderProgram = newShaderProgram;
    gl.useProgram(currentShaderProgram); 

    // vertex data - a single triangle that covers the screen
    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    SetVertexAttributeData(gl, currentShaderProgram, "a_position", gl.FLOAT, 2,
        [
            -1,  3,
             3, -1,
            -1, -1,
        ]
    );   

    // get uniforms for this shader program
    uniformMouse = gl.getUniformLocation(currentShaderProgram, "u_mouse");
    uniformBoxColor = gl.getUniformLocation(currentShaderProgram, "u_boxColor");
}

//=========================================================================================
function Initialize ()
{
    // setup webgl2
    canvas = document.getElementById("RenderWindow");
    gl = canvas.getContext("webgl2");
    if (!gl)
    {
        alert("This page requires WebGL2, which doesn't seem to be enabled ):");
        return;
    }

    // Setup mouse input stuff
    mouse.PosX = gl.canvas.width / 2;
    mouse.PosY = gl.canvas.height / 2;
    mouse.IsDown = false;
    canvas.onmousedown = function(ev)
    {
        var pos = GetPos(canvas);
        mouse.PosX =                 (ev.pageX - pos.mX)*canvas.width/canvas.offsetWidth;
        mouse.PosY = canvas.height - (ev.pageY - pos.mY)*canvas.height/canvas.offsetHeight;
        mouse.IsDown = true;
        mouseClicked = true;
    }
    canvas.onmousemove = function(ev)
    {
        if( mouse.IsDown )
        {
            var pos = GetPos( canvas );
            mouse.PosX =                 (ev.pageX - pos.mX)*canvas.width/canvas.offsetWidth;
            mouse.PosY = canvas.height - (ev.pageY - pos.mY)*canvas.height/canvas.offsetHeight;
        }
    }
    canvas.onmouseup = function(ev) {mouse.IsDown = false;}

    canvas.addEventListener("touchstart", function(ev)
    {
        ev.preventDefault();
        var pos = GetPos(canvas);
        if (ev.touches.length > 0)
        {
            mouse.PosX =                 (ev.touches[0].pageX - pos.mX)*canvas.width/canvas.offsetWidth;
            mouse.PosY = canvas.height - (ev.touches[0].pageY - pos.mY)*canvas.height/canvas.offsetHeight;
            mouse.IsDown = true;
            mouseClicked = true;            
        }        
    }
    );
    canvas.addEventListener("touchmove", function(ev)
    {
        ev.preventDefault();
        var pos = GetPos(canvas);
        if (ev.touches.length > 0)
        {
            mouse.PosX =                 (ev.touches[0].pageX - pos.mX)*canvas.width/canvas.offsetWidth;
            mouse.PosY = canvas.height - (ev.touches[0].pageY - pos.mY)*canvas.height/canvas.offsetHeight;            
        }
    }
    );
    canvas.addEventListener("touchend", function(ev)
    {
        ev.preventDefault();
        mouse.IsDown = false;
    }
    );
    canvas.addEventListener("touchcancel", function(ev)
    {
        ev.preventDefault();
        mouse.IsDown = false;
    } 
    );
    
    // set clear color to black
    gl.clearColor(0, 0, 0, 1);

    // compile all shaders
    var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource, "");
    var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource, "");
    shaderProgram = createProgram(gl, vertexShader, fragmentShader);    

    // start the render loop
    requestAnimationFrame(DrawScene);
}

</script>
</head>
<body onLoad="Initialize()">
<h1>Ray Marching A Neural Network</h1>

This is a demo to go along with my blog post: TODO: link to blog post<br>
<br>
This page uses WebGL2, which is enabled in firefox and chrome.<br>
<br>
Drag the mouse to rotate the surface. Change network topology, layer visualized, and modify weights,biases.<br>
<br>
<table class="NoBorder">
<tr>
    <td><canvas id="RenderWindow"></canvas></td>
    <td valign="top">
        <table>
        <tr><td>Draw Bounding Box:</td><td><input type="checkbox" id="u_boxColor" checked="true"/></td></tr>
        </table>
    </td>
</tr>
</table>
</body>
</html>

<pre>
TODO:
* for each layer...
 * vector of [1, input]
 * for each neuron in the layer
  * have a vector of [bias, weights].
  * dot product to get value
  * put dot product value through activation function to get neuron output
 * vector of neuron outputs is input to next layer!

* UI
 * For each layer:  have a drop down for # of neurons.
 * 0 means the layer doesn't exist.
 * make network of layers that do exist.
 * Each neuron in each layer needs as editable data: bias, weights.


* each layer takes vector of [1, input] and dot products by [bias, weights], then applies the activation function

* the 3 input values are what we use to render:
 * we ray march, plugging our ray position into the neural network to get an "inside" or "outside" value.
 * could also use gradient for a variable step size (optional)
 * ray march as per usual

* 3 input values
 * i think this is what we use to render.

* maybe try a rendering mode that is semi transparent, in case there's interesting things inside the geometry?
 * could have a transparency slider.

* select number of layers.
* should internal layers be able to have variable number of neurons? I think so!
* let user edit topology and values in neural network.
* let user select neuron activation function: step, sigma, relu. (others?)
 * could also try something based on smoothstep!
 * also check out softplus maybe?  https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
* let user edit weights and bias for each neuron.
* come up with some interesting default values.
* let user choose which layer to visualize!
* ray march the thing.

? do we need to scale things to handle values outside unit cube?
 * maybe also make the center be (0,0,0)
 * maybe make a slider to let users zoom in and out.

? do we need the option "Draw Bounding Box"?
? is there anything worth visualizing as a data point?

* write explanation of how it works.
 * like how the network has three inputs.
 * those inputs are a point in 3d space.
 * the network ultimately says "inside" or "outside"
 * this is the visualization of that space

* clean up the code, get rid of stuff not needed anymore

* find TODO's above

* blog post later!
* link to blog post

* add this to index.html and upload both to website


Blog Notes:
* Step function not differentiable.
 * does it matter?
 * i think it prevents analytical derivatives (gradient), but numeric one is fine.
</pre>